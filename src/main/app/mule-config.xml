<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:tcp="http://www.mulesoft.org/schema/mule/tcp" xmlns:vm="http://www.mulesoft.org/schema/mule/vm"
	xmlns:core="http://www.mulesoft.org/schema/mule/core" xmlns:http="http://www.mulesoft.org/schema/mule/http"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:scripting="http://www.mulesoft.org/schema/mule/scripting" xmlns="http://www.mulesoft.org/schema/mule/core"
	xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:spring="http://www.springframework.org/schema/beans"
	xmlns:mule-ss="http://www.mulesoft.org/schema/mule/spring-security"
	xmlns:ss="http://www.springframework.org/schema/security" version="CE-3.6.1"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
http://www.mulesoft.org/schema/mule/tcp http://www.mulesoft.org/schema/mule/tcp/current/mule-tcp.xsd 
http://www.mulesoft.org/schema/mule/vm http://www.mulesoft.org/schema/mule/vm/current/mule-vm.xsd 
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
http://www.mulesoft.org/schema/mule/scripting http://www.mulesoft.org/schema/mule/scripting/current/mule-scripting.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.mulesoft.org/schema/mule/spring-security http://www.mulesoft.org/schema/mule/spring-security/3.1/mule-spring-security.xsd
http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.0.xsd">


	 <spring:beans>
		<spring:bean id="seko-service-props" name="seko-service-props"
			class="org.springframework.beans.factory.config.PropertiesFactoryBean">
			<spring:property name="locations">
				<spring:list value-type="org.springframework.core.io.Resource">
					<spring:value>classpath:seko-service.properties</spring:value>
				</spring:list>
			</spring:property>
			<spring:property name="ignoreResourceNotFound" value="false" />
		</spring:bean>
	</spring:beans> 
	
	<!-- -->
		<!-- Configuration for encryptor, based on environment variables. -->
		<!-- -->
		<!-- In this example, the encryption password will be read from an -->
		<!-- environment variable called "MULE_ENCRYPTION_PASSWORD" which, once -->
		<!-- the application has been started, could be safely unset. -->
		<!-- -->
		<spring:bean id="environmentVariablesConfiguration"
			class="org.jasypt.encryption.pbe.config.EnvironmentStringPBEConfig">
			<spring:property name="algorithm" value="PBEWithMD5AndDES" />
			<spring:property name="passwordEnvName" value="MULE_ENCRYPTION_PASSWORD" />
		</spring:bean>


		<!-- -->
		<!-- The will be the encryptor used for decrypting configuration values. -->
		<!-- -->
		<spring:bean id="configurationEncryptor"
			class="org.jasypt.encryption.pbe.StandardPBEStringEncryptor">
			<spring:property name="config"
				ref="environmentVariablesConfiguration" />
		</spring:bean>

		<!-- -->
		<!-- The EncryptablePropertyPlaceholderConfigurer will read the -->
		<!-- .properties files and make their values accessible as ${var} -->
		<!-- -->
		<!-- Our "configurationEncryptor" bean (which implements -->
		<!-- org.jasypt.encryption.StringEncryptor) is set as a constructor arg. -->
		<!-- -->
		<spring:bean id="propertyConfigurer"
			class="org.jasypt.spring.properties.EncryptablePropertyPlaceholderConfigurer">
			<spring:constructor-arg ref="configurationEncryptor" />
			<spring:property name="locations">
				<spring:list>
					<spring:value>classpath:application.properties</spring:value>
					<spring:value>classpath:${runEnv}.properties</spring:value>
					<!-- <spring:value>classpath:seko-service.properties</spring:value> -->
				</spring:list>
			</spring:property>
		</spring:bean>

	<!-- specify location only to satisfy Studio - it's not used -->
	<!-- <context:property-placeholder location="classpath:application.properties" />  -->


	<configuration doc:name="Common Configuration">
		<expression-language>
			<import class="org.springframework.util.Assert" />
			<import class="java.util.Map" />
			<import class="java.util.List" />
			<import class="org.apache.log4j.NDC" />
			<import class="org.slf4j.MDC" />
			<global-functions><![CDATA[
			def props()                             { return app.registry.get('seko-service-props'); }
			def svcPropDef(propName, runEnv)        { return props().getProperty( runEnv + "." + propName, "test"); }
			def svcProp(propName)                   { return svcPropDef(propName, sessionVars.runEnv); }
			def where()                { return "in flow " + flow.name + " in app " + app.name; }
			def assertType(clazz)      { Assert.isInstanceOf(clazz, payload, "payload is of unexpected type " + where() + ": "); }
			def assertNotNull()        { Assert.notNull(payload, "payload is null " + where() + ": "); }
			def assertContains(str)    { Assert.isTrue(payload is String && payload.contains(str), "payload does not contain [" + str + "] " + where() + ": "); }
        	def throw(msg)             { Assert.isTrue(false, msg); }
			def cleanProps(map)        { result = new java.util.LinkedHashMap(map); result.remove('MULE_SESSION'); result.remove('LOCAL_CERTIFICATES'); return result; }
			def logPush()      { NDC.push(message.id); }
			def trackMsg()	   { MDC.put("Tracking_Id", message.id); }
			def logPop()       { NDC.pop(); }
	        def logIn(msg)     { return msg + " || flow: " + flow.name + " | app: " + app.name + " | node: " + mule.nodeId + " || inbound props: "  + cleanProps(message.inboundProperties)                                                                   + " | flow vars: " + flowVars + " | session vars: " + sessionVars + " | inbound payload  " + message.payloadAs(String); }
	        def logOut(msg)    { return msg + " || flow: " + flow.name + " | app: " + app.name + " | node: " + mule.nodeId + " || outbound props: " + cleanProps(message.outboundProperties) + " | flow vars: " + flowVars + " | session vars: " + sessionVars + " | outbound payload " + message.payloadAs(String); }
	        def logExc(msg)    { return msg + " || flow: " + flow.name + " | app: " + app.name + " | node: " + mule.nodeId + " || inbound props: "  + cleanProps(message.inboundProperties) +  " | outbound props: " + cleanProps(message.outboundProperties) + " | flow vars: " + flowVars + " | session vars: " + sessionVars + " | outbound payload " + message.payloadAs(String); }
	        def setPayKey(key) { HeaderUtil.setPayKey(sessionVars, key); }
	        def auditPayload(msg, pl) {
	          apl = [
	            "context" : [ "message" : msg, "app" : app.name, "node" : mule.nodeId, "cluster" : mule.clusterId ], 
	            "header"  : [ "inboundProperties" : cleanProps(message.inboundProperties), "flowVars" : flowVars, "sessionVars" : sessionVars, "outboundProperties" : cleanProps(message.outboundProperties) ]
	          ];
	          if (pl == null || (pl != 'false' && pl != false)) {
	          	if (payload != null && (payload is String || payload is Map || payload is List)) apl['payload'] = payload;
	          }
	          return apl;
	        }
        	]]></global-functions>
		</expression-language>
	</configuration>

	<http:request-config name="elastic_http_request_config"
		host="${etc.host}" port="${etc.port}" responseTimeout="5000"
		doc:name="HTTP Request Configuration">
		<http:basic-authentication username="${etc.username}"
			password="${etc.password}" />
	</http:request-config>

	<global-property name="logger.common-mule-config"
		value="com.cs.mule.configfile.common-mule-config" doc:name="Logger" />

	<http:request-config name="http_etc_shared"
		protocol="HTTP" doc:name="HTTP shared giftcard request connector">
		<http:basic-authentication username="${etc.username}"
			password="${etc.password}" />
		<tcp:client-socket-properties keepAlive="true" />
	</http:request-config>


	<vm:connector name="vm-conn-es-shared"
		validateConnections="true" doc:name="VM Connector for es">
		<core:receiver-threading-profile
			poolExhaustedAction="WAIT" maxThreadsActive="${vm.conn.es.max.threads.active}"
			maxThreadsIdle="${vm.conn.es.max.threads.idle}" />
		<vm:queue-profile maxOutstandingMessages="${vm.es.queue.size}">
			<core:default-in-memory-queue-store />
		</vm:queue-profile>
	</vm:connector>
	<vm:connector name="vm-conn-cs-shared"
		validateConnections="true" doc:name="VM Connector for cs">
		<core:receiver-threading-profile
			poolExhaustedAction="WAIT" maxThreadsActive="${vm.conn.cs.max.threads.active}"
			maxThreadsIdle="${vm.conn.cs.max.threads.idle}" />
		<vm:queue-profile maxOutstandingMessages="${vm.cs.queue.size}">
			<core:default-in-memory-queue-store />
		</vm:queue-profile>
	</vm:connector>
	
	<vm:endpoint name="vm-es-requ-ep" exchange-pattern="one-way"
		path="vm-audit-requ" connector-ref="vm-conn-es-shared" doc:name="shared es requests queue" />
	<vm:endpoint name="vm-cs-requ-ep" exchange-pattern="one-way"
		path="vm-cs-requ" connector-ref="vm-conn-cs-shared" doc:name="shared es requests queue" />

	<!-- call this flow from all flows in your app which communicate outside 
		that app. Call it immediately after entering such a flow, then call audit-common. -->
	<sub-flow name="entry-log">
		<expression-component doc:name="Push Log Context"><![CDATA[logPush();
trackMsg();
]]></expression-component>
		<set-variable variableName="auditMessage" value="entered"
			doc:name="audit message" />
	</sub-flow>
</mule>
